library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.std_logic_signed.all;
USE ieee.std_logic_unsigned.all; -- allows numerical operations (+, -)


ENTITY ALU_TB IS
            
END ALU_TB;

ARCHITECTURE rtl OF ALU_TB IS -- register transfer level

component ALU is

PORT (
-- I/O declaration
 Acc_in:        IN STD_LOGIC_VECTOR (7 DOWNTO 0);          -- input to accumulator
 Data_Reg_in:   IN STD_LOGIC_VECTOR (7 DOWNTO 0);          -- input to data register
 Opcode_in:     IN STD_LOGIC_VECTOR (3 DOWNTO 0);          -- selector input
 Q :            OUT std_logic_vector(7 downto 0);           --Accumulator output
 Ext_Data_Out:  OUT std_logic_vector(7 downto 0);           --external output of ALU

 --Flag output
 ZFL: OUT STD_LOGIC;             -- Acc=0
 OVR: OUT STD_LOGIC;             -- Acc overflow
 AED: OUT STD_LOGIC             -- Acc=Data-Reg
 );                  
end component;

--signal declaration.
signal a_in :      std_logic_vector(7 downto 0);                  --accumulator unsigned signal
signal d_in :      std_logic_vector(7 downto 0);                  -- data_reg unsigned signal
signal arith_out: std_logic_vector(7 downto 0);				     -- Arith. unit resultsignal 
signal logic_out: std_logic_vector(7 downto 0);	                 -- Logic  unit result
signal reset:     std_logic_vector(7 downto 0):="00000000";      -- reset signal declaration with set value
signal set:       std_logic_vector(7 downto 0):="11111111"; 
signal y:         std_logic_vector(7 downto 0);	                 -- Global result
signal Opcode_in: STD_LOGIC_VECTOR (3 DOWNTO 0);          -- selector input
signal acc_0:    STD_LOGIC;             -- Acc=0
signal overflow: STD_LOGIC;             -- Acc overflow
signal A_D:      STD_LOGIC;              -- Acc=Data-Reg

begin

uut: ALU_TB PORT MAP (

a_in <= a_in,    --ACC in signal
d_in <=d_in, -- Data_reg signal
acc_0<= acc_0,         --acc=0 signal
overflow<= overflow,      --overflow signal
A_D<= a_D,           -- ACC=Data_Reg signal
logic_out <= logic_out,      -- calculation results are transfered to accumulator output<= arith_out;
arith_out<=arith_out,
Opcode_in<=Opcode_in 
);
 
-- Stimulus process
 stim_proc: process
 begin
 -- hold reset state for 100 ns.
 wait for 100 ns;
 
-- insert stimulus here
 
 a_in <= "10000001";
 d_in <= "11110000";
  
 Opcode_in <= "000";
 wait for 100 ns;
 Opcode_in <= "001";
 wait for 100 ns;
 Opcode_in <= "010";
 wait for 100 ns;
 Opcode_in <= "011";
 wait for 100 ns;
 Opcode_in <= "100";
 wait for 100 ns;
 Opcode_in <= "101";
 wait for 100 ns;
 Opcode_in <= "110";
 wait for 100 ns;
 Opcode_in <= "111";
 end process;
 
END;
