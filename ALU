library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.std_logic_signed.all;
USE ieee.std_logic_unsigned.all; -- allows numerical operations (+, -)


ENTITY ALU IS
 PORT (
-- I/O declaration
 Acc_in:        IN STD_LOGIC_VECTOR (7 DOWNTO 0);          -- input to accumulator
 Data_Reg_in:   IN STD_LOGIC_VECTOR (7 DOWNTO 0);          -- input to data register
 Opcode_in:     IN STD_LOGIC_VECTOR (3 DOWNTO 0);          -- selector input
 Q :            OUT std_logic_vector(7 downto 0);           --Accumulator output
 Ext_Data_Out:  OUT std_logic_vector(7 downto 0);           --external output of ALU

 --Flag output
 ZFL: OUT STD_LOGIC;             -- Acc=0
 OVR: OUT STD_LOGIC;             -- Acc overflow
 AED: OUT STD_LOGIC             -- Acc=Data-Reg
 );                             
END ALU;

ARCHITECTURE rtl OF ALU IS -- register transfer level

--signal declaration.
signal a_in :      std_logic_vector(7 downto 0);                  --accumulator unsigned signal
signal d_in :      std_logic_vector(7 downto 0);                  -- data_reg unsigned signal
signal arith_out: std_logic_vector(7 downto 0);				     -- Arith. unit resultsignal 
signal logic_out: std_logic_vector(7 downto 0);	                 -- Logic  unit result
signal reset:     std_logic_vector(7 downto 0):="00000000";      -- reset signal declaration with set value
signal set:       std_logic_vector(7 downto 0):="11111111"; 
signal y:         std_logic_vector(7 downto 0);	                 -- Global result

signal acc_0:    STD_LOGIC;             -- Acc=0
signal overflow: STD_LOGIC;             -- Acc overflow
signal A_D:      STD_LOGIC;              -- Acc=Data-Reg
begin

a_in <= Acc_in;      --ACC in signal
d_in <= Data_Reg_in; -- Data_reg signal
acc_0<= ZFL;         --acc=0 signal
overflow<= OVR;      --overflow signal
A_D<= AED;           -- ACC=Data_Reg signal
Q <= logic_out;      -- calculation results are transfered to accumulator output
Q <= arith_out;

 
WITH Opcode_in(3 DOWNTO 0) SELECT
 arith_out <= 
             reset WHEN "0000",
             set   WHEN "1001",
             a_in +'1' WHEN "0001",
             a_in + d_in WHEN "0010",
             a_in - d_in WHEN "0011",
             a_in * d_in WHEN "0100",
             null  WHEN OTHERS;
             
WITH Opcode_in (3 DOWNTO 0) SELECT
 logic_out <=  
             a_in nand d_in WHEN "0111",
             a_in xor d_in WHEN "1000",
             std_logic_vector(shift_left(unsigned(a_in), to_integer(unsigned(d_in)))) WHEN "0101",
             std_logic_vector(shift_right(unsigned(a_in), to_integer(unsigned(d_in)))) WHEN "0110",
             null WHEN OTHERS;
            
 WITH Opcode_in(3 DOWNTO 0) SELECT
 Q <= 
      arith_out WHEN "0000" | "1001" | "0001" | "0010" | "0011"| "0100",
      logic_out WHEN "0111"| "1000"| "0101"| "0110";
      
-- Flags
acc_0    <= '1' when a_in=0 else '0'; --when calculation engine detects accumulator outpu=0
A_D      <= '1' when a_in = d_in else '0' ;


 
 end architecture rtl;  
